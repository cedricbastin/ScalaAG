\section{Future work}
With the current framework all attributes need to be declared explicitly in the \verb/AttrEnv/ type (which might be a case class or heterogeneous tuple) as they are not directly associated with the nodes themselves but rather present some global information of the parsing process which can be used and augmented by consecutive parsers.
As the parsing process generally works from left to right the only way to use attributes from a right hand side parser (e.g. value of a tree node) is by using the the lazy evaluation workaround used by the \verb/RepMin/ example.
Using several attribute algebras at once is still tedious and requires manual composition as the attribute type and the correspondong semantic functions needs to be adapted by hand to carry and manipulate the values of both computations.

In the current implementation the full parse tree is replace by the attributes, if this was to be avoided then we would need to include both the original return value as well as the manipulated one in the ParseResult. This would however also mean that the programmer needs to handle those cases explicitly which would change the interface from the traditional scala parser combinator framework.

\section{Acknowledgement}
I would like to thank my supervisors Sandro and Mano for the very interesting and insightful discussions. Through weekly meetings we were able to explore the different options as well a limitations caused by either the programming language or the choice of implementation such that the development of the project also helped to explore the theory behind parsing and attribute grammars.

\begin{thebibliography}{9}
\bibitem{tql}
  Traversal Query Language For Scala.Meta
  Eric Beguet, EPFL,
  2014
\bibitem{fastparsers}
  Accelerating parser combinators with macros
  Eric Beguet, EPFL,
  \url{https://github.com/begeric/FastParsers}
  2014
\bibitem{kiama}
  Kiama,
  \emph{A Scala library for language processing}
  \url{https://code.google.com/p/kiama/}
\bibitem{scalapc}
  Scala Parser Combinators,
  \url{https://github.com/scala/scala-parser-combinators}
\bibitem{attrurl}
  Why attribute grammars matter,
  The Monad Reader,
  \url{https://wiki.haskell.org/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter}
  2005.
\bibitem{haskell}
  Generalising Tree Traversals to DAGs,
  Patrick Bahr, Emil Axelsson,
  2015.
\bibitem{monadic}
  Monadic Parser Combinator,
  Graham Hutton, Erik Meijer,
  1996.
\bibitem{monads}
  Monads for functional programming,
  Philip Wadler, University of Glasgow
  1995.
\bibitem{dynaprog}
  DynaProg for Scala,
  \emph{A Scala DSL for Dynamic Programming on CPU and GPU},
  Thierry Coppey, Master Thesis,
  2013.
\bibitem{knuth}
  Semantics of context-free languages,
  Don Knuth,
  1967.
\end{thebibliography}
