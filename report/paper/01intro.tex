\section{Introduction \& motivation}
Parsing is still an interesting topic as programming languages evolve and some compiler developers might still be dreaming about a **one-pass compiler** or at least to apply several manipulating steps at once. Those steps require more knowledge about the tree structure in general which can be acquired by defining several recursive functions over the parse tree which pass around the additional information needed. Another method to achieve this is to use attribute grammar to augment the existing nodes in the tree with the needed information which can then be accessed several times from different locations.
Parser combinators have shown that it is possible to have an compostable and easy to use parsing framework which allows to quickly create parsers for an input of your choice. without the need to write complicated parsers by hand nor to use parser generating tools. We wanted to achieve the same ease of use by providing a parsing framework with more functionality such that more manipulating steps can already be calculated during the parsing.

On the other hand nowadays parsing is used the most frequently in combination with information coming from the web such as html or xml where only part of the information is potentially useful which in the past could only be abstracted after constructing the full parse tree.

Tree structures are often used to structure data as they implicitly encode the relationship between different data points. Hence many tree manipulation techniques have been introduced to allow many different applications such as traversers, transformers and collectors.

In each application it is possible that local knowledge is not enough for example a transformer might need global knowledge of the tree and a traverser need a environment to accumulate the different results. One concrete application would be context sesitive parsing which requires knowledge of previously seen in order for example to assign a type to variables in a parsed program. Those additional parameters could in some cases be encoded into a tupled return type however is this solution not generic and requires to change the parser each time you want to exctract a different functionality. An easier to use approach would allow the programmer to plug a different semantic function into the parser depending on his need.

Even though attributes grammar have been around for almost as long as functional programming they never really gained popularity. We wanted to revisit the related techniques to provide a more accessible framework to use them.

The *credit-card transformation* helped to avoid multiple passes over a tree by tupling results and making then evaluated lazily.

Scala Combinator have been implemented and used in a variety of programming languages to facilitate the task of the parser writer to reduce it to a simple composition of smaller parsers

During the development of the project we considered various implementations of such a framework. One of which was based on TQL, developed by Eric Beguet, however did we find the use of Monoid a limiting factors as they don't help to see the full hierarchy of the tree and treats all the nodes in the same fashion.
We will also cover related work where some research has been done 
