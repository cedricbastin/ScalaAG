\section{Introduction \& Motivation}
Parsing is still an interesting topic as programming languages evolve and some compiler developers might still be dreaming about a \textbf{one-pass compiler} or at least would like to apply several manipulating steps at once. Those steps require more knowledge about the tree structure in general which can be acquired by defining several recursive functions over the parse tree which pass around the additional information needed. Another method to achieve this is to use attribute grammar to augment the existing nodes in the tree with the needed information which can then be accessed several times from different locations. Attribute grammars allow to defined a set of attribute on a tree node, this information is then made available without changing the original tree structure.
Parser combinators have shown that it is possible to have a compostable and easy to use parsing framework which allows to quickly create parsers for an input alphabet of your choice without the need to write complicated parsers by hand nor to use parser generating tools. We wanted to achieve the same ease of use by providing a parsing framework with more functionality such that more manipulating steps can already be calculated during the parsing.

On the other hand nowadays parsing is used the most frequently in combination with information coming from the web such as html or xml where only part of the information is potentially useful which in the past could only be abstracted after constructing the full parse tree.

Tree structures are often used to structure data as they implicitly encode the relationship between different data points. Hence many tree manipulation techniques have been introduced to allow different applications such as traversers, transformers and collectors.

In each application it is possible that local knowledge is not enough for the needed functionality, for example a transformer might need global knowledge of the tree and a collector might need an environment to accumulate the different results. One concrete application would be context sensitive parsing which requires knowledge of previously seen data in order to continue parsing. Those additional parameters could in some cases be encoded into a tupled return type, this solution however is not generic and requires to change the parser each time you want to extract a different information. An easier to use approach would allow the programmer to plug a different semantic function into the parser depending on his needs.

Even though attributes grammar have been around for almost as long as functional programming they never really gained a lot of popularity. We wanted to revisit the related techniques to provide a more accessible framework to use them in combination with parsing.

Scala Combinator have been implemented and used in a variety of programming languages to facilitate the task of the parser writer to reduce it to a simple composition of smaller parsers

During the development of the project we considered various implementations of such a framework. One of which was based on TQL, developed by Eric Beguet, however did we find the use of Monoid a limiting factors as they don't help to see the full hierarchy of the tree and treats all the nodes in the same fashion.
